#!/usr/bin/env node
'use strict'

/**
 * Module dependencies
 */
var fs = require('fs')
var minimist = require('minimist')
var update = require('update-notifier')
var chalk = require('chalk')
var child = require('child_process')
var pathExists = require('path-exists')
var figures = require('figures')
var log = require('log-update')
var table = require('text-table')
var pkg = require('./package')

update({pkg: pkg}).notify()

var cli = minimist(process.argv.slice(2), {
	'--': true,
	'alias': {
		n: 'node',
		h: 'help'
	}
})
/**
 * Print help
 */
if (cli.help) {
	console.log([
		'',
		'Usage:',
		'',
		'  --node/-n <version>:  Add a node version to test',
		'  -- <command>:         The test command you expect',
		'  --disable-badge:      Disable auto-update testen badge',
		''
	].join('\n'))
	process.exit()
}

/**
 * Ensure we got a command to excute
 */
var command = cli['--']
if (command.length === 0) {
	error('Require a command to excute!')
}

/**
 * Ensure we got some node versions
 */
if (!cli.node || cli.node.length === 0) {
	error('Require providing node versions!')
}

/**
 * Get node version before test
 */
var runNode = child.spawnSync('node', ['-v'])
var nodeVersion = runNode.stdout.toString().substring(1)

/**
 * Run test
 */
var finalStatus = 0
// ensure `node versions` is an array
if (typeof cli.node === 'string') {
	cli.node = [cli.node]
}
var msg = ''
var result = cli.node.map(function (version) {
	return ['  ' + chalk.gray(figures.circle), version, chalk.gray('running')]
})
logResult(result)
cli.node.forEach(function (version, index) {
	//console.log(chalk.cyan('testing in node ' + version))
	var setVersion = child.spawnSync('n', [version])
	handleError(setVersion)
	var test = child.spawnSync(command[0], command.slice(1))
	if (test.status === 1) {
		result[index] = ['  ' + chalk.red(figures.cross), version, chalk.red('failed')]
		finalStatus = 1
		msg += chalk.bold('error occurs when testing with Node ' + version) + '\n' +
			(test.stderr.toString().trim() ? test.stdout.toString() : test.stdout.toString())
		logResult(result)
	} else {
		result[index] = ['  ' + chalk.green(figures.tick), version, chalk.green('passed')]
		logResult(result)
	}
})

/**
 * Recover node version after test
 */
recover()
function recover() {
	child.spawnSync('n', [nodeVersion], {stdio: 'inherit'})
}

updateBadge()
process.exit(finalStatus)

/**
 * Log in table
 */
function logResult(res) {
	log(msg + '\n' + table(res) + '\n')
}

/**
 * Error util
 */
function error(msg) {
	console.log(chalk.red(msg))
	process.exit()
}

/**
 * Update badge
 */
function updateBadge() {
	if (!cli['disable-badge'] && pathExists.sync('./README.md')) {
		var badge = finalStatus === 0 ?
			'https://img.shields.io/badge/testen-passing-brightgreen.svg' :
			'https://img.shields.io/badge/testen-failed-red.svg'
		var content = fs.readFileSync('./README.md', 'utf8')
		content = content.replace(
			/!\[testen badge\]\([^.]*\)/g,
			'![testen badge](' + badge + ')'
		)
		fs.writeFileSync('./README.md', content, 'utf8')
	}
}

/**
 * Handle error
 */
function handleError(command) {
	if (command.error) {
		recover()
		throw new Error(command.error)
	}
}
